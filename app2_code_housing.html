<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>app2 (2).py</title>
</head>
<body>
<pre><code>
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
from statsmodels.formula.api import ols
from scipy import stats
from statsmodels.stats.outliers_influence import variance_inflation_factor
from statsmodels.stats.diagnostic import het_breuschpagan
from sklearn.metrics import mean_squared_error, mean_absolute_error
import warnings

# Ignorar avisos que podem poluir o dashboard
warnings.filterwarnings(&quot;ignore&quot;)
st.set_page_config(page_title=&quot;An√°lise Imobili√°ria - Ames&quot;, layout=&quot;wide&quot;)

# --- CABE√áALHO FIXO COM CSS ---
header_html = &quot;&quot;&quot;
&lt;style&gt;
    #app-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background-color: #0f1116; 
        color: #fafafa;          
        padding: 10px 25px;
        z-index: 999;             
        border-bottom: 1px solid #31333f;
        text-align: center;
    }
    #app-header h2 {
        margin: 0;
        font-size: 26px;
        font-weight: 600;
    }
    #app-header p {
        margin: 5px 0 0 0;
        font-size: 16px;
        color: #a3a3a3; 
    }
    .main .block-container {
        padding-top: 7rem; 
    }
&lt;/style&gt;

&lt;div id=&quot;app-header&quot;&gt;
    &lt;h2&gt;üè° An√°lise de Dados Imobili√°rios: Ames, Iowa&lt;/h2&gt;
    &lt;p&gt;Integrantes: Pedro Russo e Daniel Vianna&lt;/p&gt;
&lt;/div&gt;
&quot;&quot;&quot;
st.markdown(header_html, unsafe_allow_html=True)

# --- CARREGAMENTO E CACHE DOS DADOS ---
@st.cache_data
def load_data():
    &quot;&quot;&quot;Carrega e faz um pr√©-processamento leve nos dados.&quot;&quot;&quot;
    df_loaded = pd.read_csv(&quot;AmesHousing.csv&quot;)
    df_loaded.columns = df_loaded.columns.str.replace(&#x27; &#x27;, &#x27;&#x27;)
    
    numeric_cols_to_impute = [&#x27;MasVnrArea&#x27;, &#x27;BsmtFinSF1&#x27;, &#x27;TotalBsmtSF&#x27;, &#x27;GarageCars&#x27;, &#x27;OverallQual&#x27;]
    for col in numeric_cols_to_impute:
        if col in df_loaded.columns:
            df_loaded[col].fillna(df_loaded[col].median(), inplace=True)
            
    categorical_cols_to_impute = [&#x27;BsmtQual&#x27;, &#x27;FireplaceQu&#x27;, &#x27;GarageType&#x27;, &#x27;MSZoning&#x27;, &#x27;HouseStyle&#x27;, &#x27;BldgType&#x27;]
    for col in categorical_cols_to_impute:
         if col in df_loaded.columns:
            df_loaded[col].fillna(df_loaded[col].mode()[0], inplace=True)
    return df_loaded

df_original = load_data()

# --- BARRA LATERAL DE NAVEGA√á√ÉO E FILTROS ---
st.sidebar.title(&quot;Navega√ß√£o&quot;)
aba = st.sidebar.radio(&quot;Selecione a An√°lise:&quot;, [&quot;üìä Vis√£o Geral&quot;, &quot;üìà Etapa I ‚Äì ANOVA&quot;, &quot;üìâ Etapa II ‚Äì Regress√£o&quot;, &quot;üìò Sobre o Projeto&quot;])

st.sidebar.markdown(&quot;---&quot;)
st.sidebar.header(&quot;Filtros Gerais&quot;)
st.sidebar.markdown(&quot;Filtre os dados para refinar as an√°lises em todas as abas.&quot;)

if &#x27;OverallQual&#x27; in df_original.columns and not df_original[&#x27;OverallQual&#x27;].empty:
    overall_qual_options = sorted(df_original[&#x27;OverallQual&#x27;].unique())
    default_overall_qual = overall_qual_options
else:
    overall_qual_options = [0]
    default_overall_qual = [0]

qualidade_geral = st.sidebar.multiselect(
    &#x27;Filtre por Qualidade Geral do Im√≥vel:&#x27;,
    options=overall_qual_options,
    default=default_overall_qual
)

if &#x27;YearBuilt&#x27; in df_original.columns and not df_original[&#x27;YearBuilt&#x27;].empty:
    ano_min_orig, ano_max_orig = int(df_original[&#x27;YearBuilt&#x27;].min()), int(df_original[&#x27;YearBuilt&#x27;].max())
else:
    ano_min_orig, ano_max_orig = 1900, 2020

ano_range = st.sidebar.slider(
    &#x27;Filtre por Ano de Constru√ß√£o:&#x27;,
    min_value=ano_min_orig,
    max_value=ano_max_orig,
    value=(ano_min_orig, ano_max_orig)
)

df_filtered = df_original.copy()
if &#x27;OverallQual&#x27; in df_filtered.columns:
    df_filtered = df_filtered[df_filtered[&#x27;OverallQual&#x27;].isin(qualidade_geral)]
if &#x27;YearBuilt&#x27; in df_filtered.columns:
    df_filtered = df_filtered[
        (df_filtered[&#x27;YearBuilt&#x27;] &gt;= ano_range[0]) &amp;
        (df_filtered[&#x27;YearBuilt&#x27;] &lt;= ano_range[1])
    ]


# --- ABA 1: VIS√ÉO GERAL ---
if aba == &quot;üìä Vis√£o Geral&quot;:
    st.header(&quot;üìä Vis√£o Geral dos Dados de Im√≥veis&quot;)
    st.markdown(f&quot;Exibindo *{df_filtered.shape[0]}* de *{df_original.shape[0]}* im√≥veis ap√≥s a aplica√ß√£o dos filtros.&quot;)
    
    if not df_filtered.empty:
        col1, col2 = st.columns(2)
        with col1:
            st.subheader(&quot;Distribui√ß√£o do Pre√ßo de Venda (SalePrice)&quot;)
            fig, ax = plt.subplots()
            sns.histplot(df_filtered[&#x27;SalePrice&#x27;], kde=True, ax=ax)
            ax.set_title(&quot;Distribui√ß√£o do Pre√ßo de Venda&quot;)
            ax.set_xlabel(&quot;Pre√ßo de Venda ($)&quot;)
            ax.set_ylabel(&quot;Frequ√™ncia&quot;)
            st.pyplot(fig)

        with col2:
            st.subheader(&quot;Pre√ßo de Venda vs. Outra Vari√°vel&quot;)
            numeric_cols_scatter = [col for col in df_filtered.select_dtypes(include=np.number).columns if col not in [&#x27;PID&#x27;, &#x27;Id&#x27;, &#x27;SalePrice&#x27;]]
            if numeric_cols_scatter:
                default_scatter_var = &#x27;GrLivArea&#x27; if &#x27;GrLivArea&#x27; in numeric_cols_scatter else numeric_cols_scatter[0]
                
                x_axis_var = st.selectbox(&quot;Escolha a vari√°vel para o eixo X:&quot;, options=numeric_cols_scatter, index=numeric_cols_scatter.index(default_scatter_var))
                
                fig, ax = plt.subplots()
                sns.scatterplot(data=df_filtered, x=x_axis_var, y=&#x27;SalePrice&#x27;, alpha=0.5, ax=ax)
                ax.set_title(f&quot;Pre√ßo de Venda vs. {x_axis_var}&quot;)
                ax.set_xlabel(x_axis_var)
                ax.set_ylabel(&quot;Pre√ßo de Venda ($)&quot;)
                st.pyplot(fig)
            else:
                st.info(&quot;Nenhuma vari√°vel num√©rica dispon√≠vel para o gr√°fico de dispers√£o.&quot;)
            
        st.subheader(&quot;Amostra dos Dados&quot;)
        st.dataframe(df_filtered.head())
    else:
        st.warning(&quot;Nenhum dado dispon√≠vel ap√≥s a aplica√ß√£o dos filtros.&quot;)


# --- ABA 2: ANOVA ---
elif aba == &quot;üìà Etapa I ‚Äì ANOVA&quot;:
    st.header(&quot;üìà An√°lise de Vari√¢ncia (ANOVA)&quot;)
    st.markdown(&quot;&quot;&quot;
    *Objetivo:* Verificar se existe uma diferen√ßa estatisticamente significativa no pre√ßo m√©dio de venda (SalePrice) 
    entre diferentes categorias de uma vari√°vel escolhida. O usu√°rio deve selecionar de 2 a 3 vari√°veis sequencialmente para an√°lise.
    &quot;&quot;&quot;)

    cat_cols_anova = [col for col in df_filtered.select_dtypes(include=[&#x27;object&#x27;, &#x27;category&#x27;]).columns if df_filtered[col].nunique() &lt; 10 and df_filtered[col].nunique() &gt; 1]
    
    if not cat_cols_anova:
        st.warning(&quot;N√£o h√° vari√°veis categ√≥ricas adequadas para ANOVA ap√≥s os filtros aplicados (precisa &gt; 1 e &lt; 10 categorias √∫nicas).&quot;)
    else:
        default_anova_var = &#x27;BldgType&#x27; if &#x27;BldgType&#x27; in cat_cols_anova else cat_cols_anova[0]
        var_cat = st.selectbox(
            &quot;*1. Escolha a vari√°vel categ√≥rica para an√°lise:*&quot;,
            options=cat_cols_anova,
            index=cat_cols_anova.index(default_anova_var),
            help=&quot;A ANOVA de fator √∫nico compara o pre√ßo m√©dio entre os grupos de UMA vari√°vel por vez.&quot;
        )

        if var_cat and not df_filtered.empty:
            st.markdown(&quot;---&quot;)
            st.subheader(f&quot;An√°lise de &#x27;SalePrice&#x27; por &#x27;{var_cat}&#x27;&quot;)

            st.write(&quot;*Visualiza√ß√£o da Distribui√ß√£o:*&quot;)
            fig, ax = plt.subplots(figsize=(12, 6))
            sns.boxplot(data=df_filtered, x=var_cat, y=&#x27;SalePrice&#x27;, ax=ax)
            ax.set_title(f&quot;Distribui√ß√£o do Pre√ßo de Venda por {var_cat}&quot;)
            ax.set_xlabel(var_cat)
            ax.set_ylabel(&quot;Pre√ßo de Venda ($)&quot;)
            plt.xticks(rotation=45)
            st.pyplot(fig)
            
            st.markdown(&quot;---&quot;)
            st.subheader(&quot;2. Verifica√ß√£o dos Pressupostos da ANOVA&quot;)

            df_anova_current = df_filtered[[var_cat, &#x27;SalePrice&#x27;]].dropna()

            if df_anova_current.empty or df_anova_current[var_cat].nunique() &lt; 2:
                st.error(f&quot;N√£o h√° dados suficientes ou categorias suficientes para &#x27;{var_cat}&#x27; ap√≥s remover NaNs para realizar a ANOVA.&quot;)
            else:
                formula = f&quot;SalePrice ~ C({var_cat})&quot;
                try:
                    model_anova = ols(formula, data=df_anova_current).fit()
                    residuals = model_anova.resid
                except Exception as e:
                    st.error(f&quot;N√£o foi poss√≠vel ajustar o modelo para os res√≠duos. Erro: {e}&quot;)
                    st.stop()
                
                st.markdown(&quot;*a) Normalidade dos Res√≠duos*&quot;)
                if len(residuals) &gt; 2:
                    shapiro_test = stats.shapiro(residuals)
                    p_valor_shapiro = shapiro_test.pvalue
                    if p_valor_shapiro &lt; 0.05:
                        st.warning(f&quot;*Pressuposto violado:* Os res√≠duos *n√£o* seguem uma distribui√ß√£o normal (p-valor do teste de Shapiro-Wilk = {p_valor_shapiro:.4f}).&quot;)
                    else:
                        st.success(f&quot;*Pressuposto atendido:* Os res√≠duos parecem seguir uma distribui√ß√£o normal (p-valor do teste de Shapiro-Wilk = {p_valor_shapiro:.4f}).&quot;)
                    
                    fig_qq = sm.qqplot(residuals, line=&#x27;s&#x27;, fit=True)
                    plt.title(&quot;Gr√°fico Q-Q dos Res√≠duos&quot;)
                    st.pyplot(fig_qq)
                else:
                    st.warning(&quot;N√£o h√° res√≠duos suficientes para o teste de Shapiro-Wilk.&quot;)
                    p_valor_shapiro = 0

                st.markdown(&quot;*b) Homocedasticidade*&quot;)
                groups = [df_anova_current[&#x27;SalePrice&#x27;][df_anova_current[var_cat] == g] for g in df_anova_current[var_cat].unique()]
                groups_for_levene = [g for g in groups if len(g) &gt; 1]
                
                if len(groups_for_levene) &gt; 1:
                    levene_test = stats.levene(*groups_for_levene)
                    p_valor_levene = levene_test.pvalue
                    if p_valor_levene &lt; 0.05:
                        st.warning(f&quot;*Pressuposto violado:* As vari√¢ncias *n√£o* s√£o homog√™neas entre os grupos (p-valor do teste de Levene = {p_valor_levene:.4f}).&quot;)
                    else:
                        st.success(f&quot;*Pressuposto atendido:* As vari√¢ncias s√£o homog√™neas entre os grupos (p-valor do teste de Levene = {p_valor_levene:.4f}).&quot;)
                else:
                    st.warning(&quot;N√£o h√° grupos suficientes para realizar o teste de Levene.&quot;)
                    p_valor_levene = 0

                st.markdown(&quot;---&quot;)
                st.subheader(&quot;3. Resultados do Teste Estat√≠stico e Interpreta√ß√£o&quot;)
                
                if p_valor_shapiro &gt;= 0.05 and p_valor_levene &gt;= 0.05:
                    st.info(&quot;*Teste Aplicado: ANOVA* (pois os pressupostos foram atendidos).&quot;)
                    anova_table = sm.stats.anova_lm(model_anova, typ=2)
                    st.write(&quot;Tabela ANOVA:&quot;)
                    st.dataframe(anova_table)
                    p_valor_final = anova_table.iloc[0][&#x27;PR(&gt;F)&#x27;]
                    if p_valor_final &lt; 0.05:
                        st.success(f&quot;*Conclus√£o (ANOVA):* Existe uma diferen√ßa estatisticamente significativa nos pre√ßos m√©dios de venda entre as diferentes categorias de &#x27;{var_cat}&#x27; (p-valor = {p_valor_final:.4f}).&quot;)
                    else:
                        st.warning(f&quot;*Conclus√£o (ANOVA):* N√£o h√° evid√™ncia de uma diferen√ßa estatisticamente significativa para &#x27;{var_cat}&#x27; (p-valor = {p_valor_final:.4f}).&quot;)

                else:
                    st.info(&quot;*Teste Aplicado: Kruskal-Wallis* (alternativa n√£o param√©trica, pois um ou mais pressupostos da ANOVA foram violados).&quot;)
                    if len(groups) &gt; 1 :
                        kruskal_test = stats.kruskal(*groups)
                        p_valor_kruskal = kruskal_test.pvalue
                        st.write(f&quot;*Estat√≠stica H (Kruskal-Wallis):* {kruskal_test.statistic:.4f}&quot;)
                        st.write(f&quot;*P-valor:* {p_valor_kruskal:.4f}&quot;)
                        if p_valor_kruskal &lt; 0.05:
                            st.success(f&quot;*Conclus√£o (Kruskal-Wallis):* Existe uma diferen√ßa estatisticamente significativa nas distribui√ß√µes de pre√ßo para &#x27;{var_cat}&#x27; (p-valor = {p_valor_kruskal:.4f}).&quot;)
                        else:
                            st.warning(f&quot;*Conclus√£o (Kruskal-Wallis):* N√£o h√° evid√™ncia de uma diferen√ßa significativa para &#x27;{var_cat}&#x27; (p-valor = {p_valor_kruskal:.4f}).&quot;)
                    else:
                        st.error(&quot;N√£o foi poss√≠vel realizar o teste de Kruskal-Wallis.&quot;)
                
                st.markdown(f&quot;*Orienta√ß√£o para Corretores/Investidores:* Se &#x27;{var_cat}&#x27; mostrou impacto significativo, foque nas categorias de maior valor.&quot;)
        elif df_filtered.empty:
            st.warning(&quot;Nenhum dado dispon√≠vel ap√≥s a aplica√ß√£o dos filtros para realizar a ANOVA.&quot;)


# --- ABA 3: REGRESS√ÉO LINEAR ---
elif aba == &quot;üìâ Etapa II ‚Äì Regress√£o&quot;:
    st.header(&quot;üìâ Modelagem Preditiva com Regress√£o Linear&quot;)
    st.markdown(&quot;&quot;&quot;
    *Objetivo:* Construir um modelo para prever o SalePrice com base em m√∫ltiplas caracter√≠sticas do im√≥vel.
    &quot;&quot;&quot;)

    if df_filtered.empty:
        st.warning(&quot;Nenhum dado dispon√≠vel ap√≥s a aplica√ß√£o dos filtros para a Regress√£o Linear.&quot;)
    else:
        st.subheader(&quot;1. Sele√ß√£o de Vari√°veis e Transforma√ß√£o&quot;)
        
        num_cols_reg = df_filtered.select_dtypes(include=np.number).columns.tolist()
        num_cols_reg = [col for col in num_cols_reg if col not in [&#x27;PID&#x27;, &#x27;SalePrice&#x27;, &#x27;Id&#x27;]]

        cat_cols_reg = [col for col in df_filtered.select_dtypes(include=[&#x27;object&#x27;, &#x27;category&#x27;]).columns if df_filtered[col].nunique() &lt; 20 and df_filtered[col].nunique() &gt; 1]
        
        desired_cat_defaults = [&#x27;MSZoning&#x27;, &#x27;HouseStyle&#x27;, &#x27;BldgType&#x27;]
        actual_cat_defaults = [col for col in desired_cat_defaults if col in cat_cols_reg]
        
        desired_num_defaults = [&#x27;GrLivArea&#x27;, &#x27;TotalBsmtSF&#x27;, &#x27;YearBuilt&#x27;, &#x27;OverallQual&#x27;]
        actual_num_defaults = [col for col in desired_num_defaults if col in num_cols_reg]

        col1_reg, col2_reg = st.columns(2)
        with col1_reg:
            vars_cont = st.multiselect(
                &quot;*Escolha vari√°veis cont√≠nuas (num√©ricas):*&quot;,
                options=num_cols_reg,
                default=actual_num_defaults
            )
        with col2_reg:
            vars_cat_reg = st.multiselect(
                &quot;*Escolha vari√°veis categ√≥ricas:*&quot;,
                options=cat_cols_reg,
                default=actual_cat_defaults
            )
            
        log_transform = st.checkbox(&quot;Aplicar transforma√ß√£o logar√≠tmica em SalePrice e nas vari√°veis cont√≠nuas? (Modelo Log-Log)&quot;, value=True)

        if len(vars_cont) &gt;= 1 and len(vars_cat_reg) &gt;= 1:
            st.markdown(&quot;---&quot;)

            st.subheader(&quot;2. An√°lise Visual da Linearidade&quot;)
            st.markdown(&quot;Abaixo est√£o os gr√°ficos de dispers√£o para cada vari√°vel cont√≠nua selecionada versus o SalePrice. Isso ajuda a verificar visualmente a premissa de linearidade.&quot;)
            
            num_plots = len(vars_cont)
            cols_per_row = 3
            plot_cols = st.columns(cols_per_row)
            
            for i, var in enumerate(vars_cont):
                with plot_cols[i % cols_per_row]:
                    fig_reg, ax_reg = plt.subplots()
                    sns.regplot(data=df_filtered, x=var, y=&#x27;SalePrice&#x27;, ax=ax_reg, line_kws={&quot;color&quot;: &quot;red&quot;}, scatter_kws={&#x27;alpha&#x27;: 0.3})
                    ax_reg.set_title(f&quot;SalePrice vs. {var}&quot;, fontsize=10)
                    ax_reg.set_xlabel(var, fontsize=8)
                    ax_reg.set_ylabel(&quot;SalePrice&quot;, fontsize=8)
                    st.pyplot(fig_reg)
            
            st.markdown(&quot;---&quot;)
            st.subheader(&quot;3. Ajuste do Modelo e Resultados&quot;)
            
            # Prepara√ß√£o dos dados
            cols_for_model = [&#x27;SalePrice&#x27;] + vars_cont + vars_cat_reg
            df_model = df_filtered[cols_for_model].copy().dropna()
            
            y = df_model[&#x27;SalePrice&#x27;]
            X_vars = df_model[vars_cont + vars_cat_reg]

            if log_transform:
                y = np.log1p(y)
                for col in vars_cont:
                    if pd.api.types.is_numeric_dtype(X_vars[col]):
                        if (X_vars[col] &gt;= 0).all():
                            X_vars[col] = np.log1p(X_vars[col])
                        else:
                            st.warning(f&quot;Vari√°vel {col} n√£o transformada com log1p pois cont√©m valores negativos.&quot;)

            X_vars = pd.get_dummies(X_vars, columns=vars_cat_reg, drop_first=True, dtype=float)
            X_vars = sm.add_constant(X_vars)

            # ===================== IN√çCIO DA CORRE√á√ÉO (VERIFICA√á√ÉO DE DADOS) =====================
            num_observations = X_vars.shape[0]
            num_predictors = X_vars.shape[1]

            if num_observations &lt;= num_predictors:
                st.error(f&quot;Dados insuficientes para o modelo. Ap√≥s o preparo, h√° {num_observations} linhas e {num_predictors} preditores. O n√∫mero de linhas deve ser maior que o n√∫mero de preditores. Tente usar menos vari√°veis ou filtros menos restritivos.&quot;)
            else:
                try:
                    model_reg = sm.OLS(y, X_vars).fit()
                    
                    st.write(&quot;*Resumo do Modelo (Statsmodels OLS):*&quot;)
                    st.text(model_reg.summary())
                
                    st.markdown(&quot;---&quot;)
                    st.subheader(&quot;4. M√©tricas de Desempenho do Modelo&quot;)
                    y_pred = model_reg.predict(X_vars)
                    
                    if log_transform:
                        y_true_orig = np.expm1(y)
                        y_pred_orig = np.expm1(y_pred)
                        y_pred_orig = np.nan_to_num(y_pred_orig, nan=np.nanmedian(y_pred_orig), posinf=np.nanmax(y_true_orig[np.isfinite(y_true_orig)]))
                    else:
                        y_true_orig = y
                        y_pred_orig = y_pred

                    r2_adj = model_reg.rsquared_adj
                    rmse = np.sqrt(mean_squared_error(y_true_orig, y_pred_orig))
                    mae = mean_absolute_error(y_true_orig, y_pred_orig)
                    
                    m1, m2, m3 = st.columns(3)
                    m1.metric(label=&quot;R¬≤ Ajustado&quot;, value=f&quot;{r2_adj:.4f}&quot;)
                    m2.metric(label=&quot;RMSE (Erro M√©dio Quadr√°tico)&quot;, value=f&quot;${rmse:,.2f}&quot;)
                    m3.metric(label=&quot;MAE (Erro M√©dio Absoluto)&quot;, value=f&quot;${mae:,.2f}&quot;)
                    st.markdown(f&quot;*Discuss√£o do Ajuste:* O modelo explica aproximadamente *{r2_adj:.1%}* da vari√¢ncia no pre√ßo de venda. O MAE indica que, em m√©dia, as previs√µes do modelo (na escala original) erram em *${mae:,.2f}*.&quot;)

                    st.markdown(&quot;---&quot;)
                    st.subheader(&quot;5. Diagn√≥stico dos Pressupostos do Modelo&quot;)
                    residuals_reg = model_reg.resid

                    diag1, diag2 = st.columns(2)
                    with diag1:
                        st.markdown(&quot;*a) Linearidade e Homocedasticidade (Visual)*&quot;)
                        fig_res_fit, ax_res_fit = plt.subplots()
                        sns.scatterplot(x=model_reg.fittedvalues, y=residuals_reg, ax=ax_res_fit, alpha=0.5)
                        ax_res_fit.axhline(0, color=&#x27;red&#x27;, linestyle=&#x27;--&#x27;)
                        ax_res_fit.set_xlabel(&quot;Valores Ajustados&quot;)
                        ax_res_fit.set_ylabel(&quot;Res√≠duos&quot;)
                        ax_res_fit.set_title(&quot;Res√≠duos vs. Valores Ajustados&quot;)
                        st.pyplot(fig_res_fit)
                        st.caption(&quot;Ideal: Pontos aleatoriamente dispersos em torno da linha 0.&quot;)

                        st.markdown(&quot;*b) Normalidade dos Res√≠duos*&quot;)
                        if len(residuals_reg) &gt; 2:
                            shapiro_reg_test = stats.shapiro(residuals_reg)
                            if shapiro_reg_test.pvalue &lt; 0.05:
                                st.warning(f&quot;P-valor (Shapiro-Wilk): {shapiro_reg_test.pvalue:.4f}. Res√≠duos podem n√£o ser normais.&quot;)
                            else:
                                st.success(f&quot;P-valor (Shapiro-Wilk): {shapiro_reg_test.pvalue:.4f}. Res√≠duos parecem normais.&quot;)
                            fig_qq_reg = sm.qqplot(residuals_reg, line=&#x27;s&#x27;, fit=True)
                            plt.title(&quot;Q-Q Plot dos Res√≠duos (Regress√£o)&quot;)
                            st.pyplot(fig_qq_reg)
                        else:
                             st.warning(&quot;N√£o h√° res√≠duos suficientes para o teste de Shapiro-Wilk.&quot;)

                    with diag2:
                        st.markdown(&quot;*c) Homocedasticidade (Teste Quantitativo)*&quot;)
                        try:
                            bp_test = het_breuschpagan(residuals_reg, model_reg.model.exog)
                            if bp_test[1] &lt; 0.05:
                                st.warning(f&quot;P-valor (Breusch-Pagan): {bp_test[1]:.4f}. H√° evid√™ncia de heterocedasticidade.&quot;)
                            else:
                                st.success(f&quot;P-valor (Breusch-Pagan): {bp_test[1]:.4f}. N√£o h√° evid√™ncia de heterocedasticidade.&quot;)
                        except Exception as e_bp:
                            st.warning(f&quot;N√£o foi poss√≠vel rodar o teste de Breusch-Pagan: {e_bp}&quot;)
                        
                        st.markdown(&quot;*d) Multicolinearidade (VIF)*&quot;)
                        X_vif = X_vars.drop(&#x27;const&#x27;, axis=1, errors=&#x27;ignore&#x27;)
                        if not X_vif.empty:
                            vif_data = pd.DataFrame()
                            vif_data[&quot;Vari√°vel&quot;] = X_vif.columns
                            vif_data[&quot;VIF&quot;] = [variance_inflation_factor(X_vif.values, i) for i in range(X_vif.shape[1])]
                            st.dataframe(vif_data[vif_data[&#x27;VIF&#x27;] &gt; 0].style.apply(
                                lambda x: [&#x27;background-color: #FF7F7F&#x27; if v &gt; 5 else &#x27;&#x27; for v in x], subset=[&#x27;VIF&#x27;]))
                            st.caption(&quot;VIF &gt; 5 pode indicar multicolinearidade.&quot;)
                        else:
                            st.info(&quot;Nenhuma vari√°vel para calcular VIF.&quot;)

                    st.markdown(&quot;---&quot;)
                    st.subheader(&quot;6. Interpreta√ß√£o dos Coeficientes e Recomenda√ß√µes Pr√°ticas&quot;)
                    coef_df = pd.DataFrame({&#x27;Coeficiente&#x27;: model_reg.params, &#x27;p-valor&#x27;: model_reg.pvalues}).reset_index().rename(columns={&#x27;index&#x27;: &#x27;Vari√°vel&#x27;})
                    
                    coef_significativos = coef_df[(coef_df[&#x27;p-valor&#x27;] &lt; 0.05) &amp; (coef_df[&#x27;Vari√°vel&#x27;] != &#x27;const&#x27;)]
                    
                    if not coef_significativos.empty:
                        st.markdown(&quot;*Recomenda√ß√µes e Insights (baseado em vari√°veis com p-valor &lt; 0.05):*&quot;)
                        for _, row in coef_significativos.iterrows():
                            var, coef_val = row[&#x27;Vari√°vel&#x27;], row[&#x27;Coeficiente&#x27;]
                            original_cat_var_name = next((cat_var for cat_var in vars_cat_reg if cat_var in var), None)

                            if log_transform:
                                impacto_desc = &quot;aumenta&quot; if coef_val &gt; 0 else &quot;reduz&quot;
                                if original_cat_var_name:
                                    st.markdown(f&quot;‚Ä¢ Ser da categoria *&#x27;{var.replace(original_cat_var_name + &#x27;_&#x27;, &#x27;&#x27;)}&#x27;* *{impacto_desc}* o pre√ßo em *{abs(coef_val):.2%}*.&quot;)
                                elif var in vars_cont:
                                    st.markdown(f&quot;‚Ä¢ Um aumento de 1% em *&#x27;{var}&#x27;* *{impacto_desc}* o pre√ßo em *{abs(coef_val):.2%}*.&quot;)
                            else:
                                impacto_desc = &quot;aumenta&quot; if coef_val &gt; 0 else &quot;reduz&quot;
                                if original_cat_var_name:
                                    st.markdown(f&quot;‚Ä¢ Ser da categoria *&#x27;{var.replace(original_cat_var_name + &#x27;_&#x27;, &#x27;&#x27;)}&#x27;* *{impacto_desc}* o pre√ßo em *${abs(coef_val):,.0f}*.&quot;)
                                elif var in vars_cont:
                                    st.markdown(f&quot;‚Ä¢ Um aumento de uma unidade em *&#x27;{var}&#x27;* *{impacto_desc}* o pre√ßo em *${abs(coef_val):,.0f}*.&quot;)
                        st.caption(&quot;Interpreta√ß√µes s√£o ceteris paribus (mantendo outras vari√°veis constantes).&quot;)
                    else:
                        st.warning(&quot;Nenhuma vari√°vel selecionada apresentou impacto estatisticamente significativo.&quot;)
                
                except Exception as e_reg:
                    st.error(f&quot;Erro ao ajustar o modelo de regress√£o: {e_reg}&quot;)
            # ===================== FIM DA CORRE√á√ÉO (VERIFICA√á√ÉO DE DADOS) =====================

        else:
            st.warning(&quot;Por favor, selecione pelo menos uma vari√°vel cont√≠nua e uma categ√≥rica para a an√°lise de regress√£o.&quot;)


# --- ABA 4: SOBRE O PROJETO ---
elif aba == &quot;üìò Sobre o Projeto&quot;:
    st.header(&quot;üìò Sobre o Projeto e Autoria&quot;)
    st.markdown(&quot;&quot;&quot;
    Este dashboard interativo foi desenvolvido como parte da disciplina de Sistemas de Informa√ß√µes em Engenharia de Produ√ß√£o, com o objetivo de analisar os fatores que influenciam o pre√ßo de im√≥veis na cidade de Ames, Iowa, utilizando t√©cnicas de ANOVA e Regress√£o Linear M√∫ltipla.
    
    *Autores:* Pedro Russo e Daniel Vianna
    &quot;&quot;&quot;)
    
    st.markdown(&quot;---&quot;)
    st.subheader(&quot;üìå Funcionalidades e Requisitos Atendidos&quot;)
    st.markdown(&quot;&quot;&quot;
    - ‚úîÔ∏è *An√°lise Explorat√≥ria e Comparativa com ANOVA (Etapa I)*
    - ‚úîÔ∏è *Modelagem Preditiva com Regress√£o Linear (Etapa II)*
    - ‚úîÔ∏è *B√¥nus de Inova√ß√£o*: Dashboard interativo, filtros, gr√°ficos e interpreta√ß√µes.
    &quot;&quot;&quot;)
</code></pre>
</body>
</html>
